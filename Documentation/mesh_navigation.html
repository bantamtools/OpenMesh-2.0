<html>
    <head>
      <title>OpenMesh: How to navigate on a mesh</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">OpenMesh Documentation</a>      </li>
      <li><a class="el" href="mesh_docu.html">Using and understanding OpenMesh</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>How to navigate on a mesh </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="nav_overview"></a>
Overview</h2>
<ul>
<li><a class="el" href="mesh_navigation.html#nav_intro">Introduction</a> </li>
<li><a class="el" href="mesh_navigation.html#nav_he">Navigating over halfedges</a> </li>
<li><a class="el" href="mesh_navigation.html#nav_bound">Mesh boundaries</a> </li>
<li><a class="el" href="mesh_navigation.html#nav_io">Using incoming and outgoing halfedges</a> </li>
<li><a class="el" href="mesh_navigation.html#nav_opposite">Using opposite halfedges</a></li>
</ul>
<h2><a class="anchor" id="nav_intro"></a>
Introduction</h2>
<p>In this tutorial you will learn how to navigate on a mesh using the OpenMesh library. In the previous chapter (see <a class="el" href="mesh_iterators.html">Mesh Iterators and Circulators</a>) you have learned how to iterate over vertices, edges, halfedges and faces as well as circulate over certain structures such as 1-rings and many more. So in this tutorial we will focus on efficiently using the halfedge data structure and some very useful attributes such as the boundary flag. We assume that you already made yourself familiar with the halfedge structure which is used in OpenMesh. Further information on this topic can be found in <a class="el" href="mesh_hds.html">The Halfedge Data Structure</a>.</p>
<h2><a class="anchor" id="nav_he"></a>
Navigating over halfedges</h2>
<p>So let's start with navigating over halfedges of a mesh. Assume we have the following mesh topology:</p>
<div align="center">
<img src="mesh.normal.png" alt="mesh.normal.png"/>
</div>
<p>We can now select an arbitrary halfedge of this mesh which then offers either one of two possible navigations:</p>
<ul>
<li>If the chosen halfedge lies at a boundary or in other words is not adjacent to a face, we can now navigate along the boundary (or hole) of our mesh by using <code>next_halfedge_handle()</code> or <code>prev_halfedge_handle()</code>:</li>
</ul>
<div align="center">
<img src="mesh.outer.png" alt="mesh.outer.png"/>
</div>
<ul>
<li>If the chosen halfedge is adjacent to a face, we can then navigate along all halfedges that are adjacent to this face. In other words we circulate around the inner halfedges of one face:</li>
</ul>
<div align="center">
<img src="mesh.inner.png" alt="mesh.inner.png"/>
</div>
<p>In both cases the code would look something like the following example. Depending on whether the initial halfedge is adjacent to a face or not, we will either navigate on the boundary halfedges of our mesh or along the inner halfedges of a face: </p>
<div class="fragment"><pre class="fragment">[...]

TriMesh::HalfedgeHandle heh, heh_init;

<span class="comment">// Get the halfedge handle assigned to vertex[0]</span>
heh = heh_init = mesh.halfedge_handle(vertex[0].handle());

<span class="comment">// heh now holds the handle to the initial halfedge.</span>
<span class="comment">// We now get further on the boundary by requesting</span>
<span class="comment">// the next halfedge adjacent to the vertex heh</span>
<span class="comment">// points to...</span>
heh = mesh.next_halfedge_handle(heh);

<span class="comment">// We can do this as often as we want:</span>
<span class="keywordflow">while</span>(heh != heh_init) {
        heh = mesh.next_halfedge_handle(heh);
}

[...]
</pre></div><p>References:<br/>
 <a class="el" href="classOpenMesh_1_1Concepts_1_1KernelT.html#a907f874b93f142afc5a08bac1983280f" title="Get the next halfedge handle.">OpenMesh::Concepts::KernelT&lt; FinalMeshItems &gt;::next_halfedge_handle()</a><br/>
 <a class="el" href="classOpenMesh_1_1Concepts_1_1KernelT.html#aa9d89ad830674141c58387e78b7590ea" title="Get the previous halfedge of the given halfedge.">OpenMesh::Concepts::KernelT&lt; FinalMeshItems &gt;::prev_halfedge_handle()</a></p>
<h2><a class="anchor" id="nav_bound"></a>
Mesh boundaries</h2>
<p>As you have seen in the previous section, navigating along boundaries is very simple. In general OpenMesh also offers a boundary attribute for edges, vertices and faces. So testing i.e. whether a face is a boundary face is quite simple using <a class="el" href="classOpenMesh_1_1PolyConnectivity.html#ab80f63880838f2488ad4f53021111e1f" title="Is the edge _eh a boundary edge, i.e.">OpenMesh::PolyConnectivity::is_boundary()</a>.<br/>
</p>
<p>So for each type we can make use of one of the following functions:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Test if a halfedge lies at a boundary (is not adjacent to a face)</span>
<span class="keywordtype">bool</span> is_boundary (HalfedgeHandle _heh) <span class="keyword">const</span>

<span class="comment">// Test if an edge lies at a boundary</span>
<span class="keywordtype">bool</span> is_boundary (EdgeHandle _eh) <span class="keyword">const</span>

<span class="comment">// Test if a vertex is adjacent to a boundary edge</span>
<span class="keywordtype">bool</span> is_boundary (VertexHandle _vh) <span class="keyword">const</span>

<span class="comment">// Test if a face has at least one adjacent boundary edge.</span>
<span class="comment">// If _check_vertex=true, this function also tests if at least one</span>
<span class="comment">// of the adjacent vertices is a boundary vertex</span>
<span class="keywordtype">bool</span> is_boundary (FaceHandle _fh, <span class="keywordtype">bool</span> _check_vertex=<span class="keyword">false</span>) const
</pre></div><h2><a class="anchor" id="nav_io"></a>
Using incoming and outgoing halfedges</h2>
<p>OpenMesh offers quite a lot of iterators and circulators to easily iterate over the structures of a mesh. A very helpful iterator is the <a class="el" href="classOpenMesh_1_1PolyConnectivity.html#abed02371230a5195ccc77f2e0814baaa" title="Circulator.">OpenMesh::PolyConnectivity::VertexIHalfedgeIter</a> or the <a class="el" href="classOpenMesh_1_1PolyConnectivity.html#accd78f05ad24da07e2cd7b30819ab870" title="Circulator.">OpenMesh::PolyConnectivity::VertexOHalfedgeIter</a> which are used to iterate over all incoming/outgoing halfedges of a vertex. So, sticking to the illustration below, a OpenMesh::PolyConnectivity:V:ertexIHalfedgeIter for the lower most vertex would iterate over all incoming halfedges (blue), whereas the OpenMesh::PolyConnectivity::OpenMesh::PolyConnectivity::VertexOHalfedgeIter would iterate over all outgoing halfedges (red):</p>
<div align="center">
<img src="mesh.inout.png" alt="mesh.inout.png"/>
</div>
<p>A schematic code example of how to use the halfedge iterators as described above: </p>
<div class="fragment"><pre class="fragment">[...]

<span class="comment">// Get some vertex handle</span>
PolyMesh::VertexHandle v = ...;

<span class="keywordflow">for</span>(PolyMesh::VertexIHalfedgeIter vih_it = mesh.vih_iter(v); vih_it; ++vih_it) {
        <span class="comment">// Iterate over all incoming halfedges...</span>
}

<span class="keywordflow">for</span>(PolyMesh::VertexOHalfedgeIter voh_it = mesh.voh_iter(v); voh_it; ++voh_it) {
        <span class="comment">// Iterate over all outgoing halfedges...</span>
}

[...]
</pre></div><h2><a class="anchor" id="nav_opposite"></a>
Using opposite halfedges</h2>
<p>The halfedge structure splits every edge into two directional parts by creating two directed edges out of one undirected edge. So for every halfedge there exists its counterpart pointing in the opposite direction. OpenMesh allows to easily navigate through opposing halfedges via the function <a class="el" href="classOpenMesh_1_1Concepts_1_1KernelT.html#ab33100ddcfda860072d0662c93175f11" title="Get the opposite halfedge.">OpenMesh::Concepts::KernelT&lt; FinalMeshItems &gt;::opposite_halfedge_handle()</a>. So in the illustration below <code>opposite_halfedge_handle()</code> for the blue halfedge would return the red halfedge:</p>
<div align="center">
<img src="mesh.opp.png" alt="mesh.opp.png"/>
</div>
<p>Use this function as described in the example below:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Get the halfedge handle of i.e. the halfedge</span>
<span class="comment">// that is associated to the first vertex</span>
<span class="comment">// of our set of vertices</span>
PolyMesh::HalfedgeHandle heh = mesh.halfedge_handle(mesh.vertices_begin().handle());

<span class="comment">// Now get the handle of its opposing halfedge</span>
PolyMesh::HalfedgeHandle opposite_heh = mesh.opposite_halfedge_handle(heh);
</pre></div><p>There are also a few more functions that offer easy access to opposing structures:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Get the face adjacent to the opposite halfedge</span>
<a class="code" href="classOpenMesh_1_1PolyConnectivity.html#af8101dcdc98c8c89a8a56baef445c2ac" title="returns the face handle of the opposite halfedge">OpenMesh::PolyConnectivity::opposite_face_handle</a>();

<span class="comment">// Get the handle to the opposite halfedge</span>
<a class="code" href="classOpenMesh_1_1Concepts_1_1KernelT.html#ab33100ddcfda860072d0662c93175f11" title="Get the opposite halfedge.">OpenMesh::Concepts::KernelT::opposite_halfedge_handle</a>();

<span class="comment">// Get the opposite vertex to the opposite halfedge</span>
<a class="code" href="classOpenMesh_1_1TriConnectivity.html#acc997689fa40077f99bb27967e1288ef" title="Returns the opposite vertex to the opposite halfedge of _heh in the face referenced by it returns Inv...">OpenMesh::TriConnectivity::opposite_he_opposite_vh</a>();

<span class="comment">// Get the vertex assigned to the opposite halfedge</span>
<a class="code" href="classOpenMesh_1_1TriConnectivity.html#a919de74b6e59ee17fe5c96c663d9dcc8" title="Returns the opposite vertex to the halfedge _heh in the face referenced by _heh returns InvalidVertex...">OpenMesh::TriConnectivity::opposite_vh</a>();
</pre></div> </div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
