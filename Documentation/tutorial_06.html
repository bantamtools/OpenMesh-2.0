<html>
    <head>
      <title>OpenMesh: Using mesh attributes and traits</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">OpenMesh Documentation</a>      </li>
      <li><a class="el" href="tutorial.html">Tutorials (code examples)</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Using mesh attributes and traits </h1>  </div>
</div>
<div class="contents">
<p>this example shows how to change the data type for positions, normals, colors, and texture,</p>
<p>In the previous tutorial (<a class="el" href="tutorial_05.html">Using standard properties</a>) we learned to use standard properties by calling the appropriate <code>request</code> method. Unlike the custom properties, where the user specifies the data type by passing the type to the handle (e.g. <code>MyMesh::FPropHandleT&lt;</code> <b>int</b>&gt;), the data types of the standard properties are defined by so-called mesh traits. With traits we can customize and extend the mesh data structure. We can do this by changing two important features</p>
<ol type="1">
<li>changing data type for positions, normals, colors, and texture coordinates</li>
<li>extend mesh entities Vertex, Face, Edge, and Halfedge (see tutorial '<a class="el" href="tutorial_07.html">Extending the mesh using traits</a>')</li>
</ol>
<p>Let's start. Every custom traits should derive from the default traits</p>
 <div class="fragment"><pre class="fragment"><span class="keyword">struct </span><a class="code" href="structMyTraits.html">MyTraits</a> : OpenMesh::DefaultTraits
</pre></div></p>
<p>As mentioned, we can change the basic data types for the basic types <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#aed10fb4dfb536b53a5e20c8f2442eadf" title="Coordinate type.">MyMesh::Point</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#a3570fd132d1ac589b380485cf59c9e0b" title="Normal type.">MyMesh::Normal</a></code>, <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#af0d8129bf1a819c468c6edcb13b5203b" title="Color type.">MyMesh::Color</a></code>, and <code>MyMesh::TexCoord</code>. We can use the provided vector class or we use a different one from another library. Here we simply replace the default type <code>OpenMesh::Vec3f</code> (defined in the <code><a class="el" href="structOpenMesh_1_1DefaultTraits.html" title="Base class for all traits.">OpenMesh::DefaultTraits</a></code>) for positions and normals with <code>OpenMesh::Vec3d</code> </p>
<p><div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> OpenMesh::Vec3d Point;
  <span class="keyword">typedef</span> OpenMesh::Vec3d Normal;
</pre></div></p>
<p>(In general it's better to have the same scalar type for the point and normal vector, for instance <code>double</code> in this case. Otherwise we have to cast quite a lot depending on the implementation of the vector class.)</p>
<p>Be aware that these settings overwrite the ones of the parent traits class! As we usually derive from the DefaultTraits let's have a close look.</p>
<p>Actually the struct <code><a class="el" href="structOpenMesh_1_1DefaultTraits.html" title="Base class for all traits.">OpenMesh::DefaultTraits</a></code> is merely empty. It solely defines the types for <code>Point</code>, <code>Normal</code>, <code>TexCoord</code>, and <code>Color</code> and one attribute, that we used implicitly all the time:</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// HalfedgeAttributes( OpenMesh::Attributes::PrevHalfedge );</span>
</pre></div></p>
<p>The attribute <code>PrevHalfedge</code> is different, as it does not control a property. Yet it has a great impact on the resulting mesh type, as it adds additional information to the halfedge structure. The impact is twofold:</p>
<ol type="1">
<li>fast access to previous halfedge</li>
<li>increase of memory consumption</li>
</ol>
<p>Using this feature depends highly on our needs. One situation where the previous halfedges are quite handy, is the mesh member function add_face(). The execution time for the member function drops dramatically, when the information about the previous halfedge is available. Usually we want to have this information. But if not, because we must save memory, we can easily remove it with</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// HalfedgeAttributes( OpenMesh::Attributes::None );</span>
</pre></div></p>
<p>Then we need 8 bytes less per edge, which can be quite a lot as one can derive from the Euler formula <b style="background-color:#FFFFFF;">( <img class="formulaInl" alt="$V-E+F=2 (1-g)$" src="form_0.png"/>)</b>, that for a regular triangle meshes with genus <b style="background-color:#FFFFFF;"> <img class="formulaInl" alt="$g=0$" src="form_1.png"/></b> the number of edges <b style="background-color:#FFFFFF;"> <img class="formulaInl" alt="$E$" src="form_2.png"/></b> is approximately three times the number of vertices <b style="background-color:#FFFFFF;"> <img class="formulaInl" alt="$V$" src="form_3.png"/>: <img class="formulaInl" alt="$ E \approx 3 \cdot V$" src="form_4.png"/></b>.</p>
<p>The complete source looks like this:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;typeinfo&gt;</span>
<span class="comment">// --------------------</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>

<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Geometry/VectorT.hh&gt;</span>

<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="comment">// Define my personal traits</span>
<span class="keyword">struct </span><a class="code" href="structMyTraits.html">MyTraits</a> : OpenMesh::DefaultTraits
{
  <span class="comment">// Let Point and Normal be a vector of doubles</span>
  <span class="keyword">typedef</span> OpenMesh::Vec3d Point;
  <span class="keyword">typedef</span> OpenMesh::Vec3d Normal;

  <span class="comment">// Already defined in OpenMesh::DefaultTraits</span>
  <span class="comment">// HalfedgeAttributes( OpenMesh::Attributes::PrevHalfedge );</span>
  
  <span class="comment">// Uncomment next line to disable attribute PrevHalfedge</span>
  <span class="comment">// HalfedgeAttributes( OpenMesh::Attributes::None );</span>
  <span class="comment">//</span>
  <span class="comment">// or</span>
  <span class="comment">//</span>
  <span class="comment">// HalfedgeAttributes( 0 );</span>
};

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// Define my mesh with the new traits!</span>
<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html" title="Triangle mesh based on the ArrayKernel.">OpenMesh::TriMesh_ArrayKernelT&lt;MyTraits&gt;</a>  MyMesh;

<span class="comment">// ------------------------------------------------------------------ main ----</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh mesh;

  <span class="keywordflow">if</span> (argc!=2)
  {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;input&gt;\n&quot;</span>;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// Just make sure that point element type is double</span>
  <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>( <a class="code" href="structOpenMesh_1_1vector__traits.html#a127a4d7ca521ed3254cd801917ee67d4" title="Type of the scalar value.">OpenMesh::vector_traits&lt;MyMesh::Point&gt;::value_type</a> ) 
       != <span class="keyword">typeid</span>(<span class="keywordtype">double</span>) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Ouch! ERROR! Data type is wrong!\n&quot;</span>;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// Make sure that normal element type is double</span>
  <span class="keywordflow">if</span> ( <span class="keyword">typeid</span>( <a class="code" href="structOpenMesh_1_1vector__traits.html#a127a4d7ca521ed3254cd801917ee67d4" title="Type of the scalar value.">OpenMesh::vector_traits&lt;MyMesh::Normal&gt;::value_type</a> ) 
       != <span class="keyword">typeid</span>(<span class="keywordtype">double</span>) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Ouch! ERROR! Data type is wrong!\n&quot;</span>;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// Add vertex normals as default property (ref. previous tutorial)</span>
  mesh.request_vertex_normals();

  <span class="comment">// Add face normals as default property</span>
  mesh.request_face_normals();

  <span class="comment">// load a mesh</span>
  <a class="code" href="classOpenMesh_1_1IO_1_1Options.html" title="Set options for reader/writer modules.">OpenMesh::IO::Options</a> opt;
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#ae4b7d0255a084aca13f5c7a553b86e72" title="Read a mesh from file _filename.">OpenMesh::IO::read_mesh</a>(mesh,argv[1], opt))
  {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error loading mesh from file &quot;</span> &lt;&lt; argv[1] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// If the file did not provide vertex normals, then calculate them</span>
  <span class="keywordflow">if</span> ( !opt.check( <a class="code" href="classOpenMesh_1_1IO_1_1Options.html#a9f4f797b08c045b611eaa6f8d149da21ad989c6d671050e12953b648c4c72dded" title="Has (r) / store (w) vertex normals.">OpenMesh::IO::Options::VertexNormal</a> ) &amp;&amp;
       mesh.has_face_normals() &amp;&amp; mesh.has_vertex_normals() )
  {
    <span class="comment">// let the mesh update the normals</span>
    mesh.<a class="code" href="classOpenMesh_1_1PolyMeshT.html#a601f21014e50bd5a2243b0e4849c9c14" title="Calls update_face_normals() and update_vertex_normals() if these normals (i.e.">update_normals</a>();
  }

  <span class="comment">// move all vertices one unit length along it&#39;s normal direction</span>
  <span class="keywordflow">for</span> (MyMesh::VertexIter v_it = mesh.vertices_begin();
       v_it != mesh.vertices_end(); ++v_it)
  {
    std::cout &lt;&lt; <span class="stringliteral">&quot;Vertex #&quot;</span> &lt;&lt; v_it &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; mesh.point( v_it );
    mesh.set_point( v_it, mesh.point(v_it)+mesh.normal(v_it) );
    std::cout &lt;&lt; <span class="stringliteral">&quot; moved to &quot;</span> &lt;&lt; mesh.point( v_it ) &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
