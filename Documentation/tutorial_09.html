<html>
    <head>
      <title>OpenMesh: Storing custom properties</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">OpenMesh Documentation</a>      </li>
      <li><a class="el" href="tutorial.html">Tutorials (code examples)</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Storing custom properties </h1>  </div>
</div>
<div class="contents">
<p>The OpenMesh' proprietary OM format allows to store and restore custom properties along with the standard properties.</p>
<p>For it we have to use named custom properties like the following one</p>
 <div class="fragment"><pre class="fragment">  <a class="code" href="structOpenMesh_1_1VPropHandleT.html">OpenMesh::VPropHandleT&lt;float&gt;</a>       vprop_float;
  mesh.add_property(vprop_float,  <span class="stringliteral">&quot;vprop_float&quot;</span>);
</pre></div></p>
<p>Here we registered a float property for the vertices at the mesh with name "vprop_float". The name of a property, that we want to make persistent, must follow a few rules</p>
<ol type="1">
<li>max. 256 characters long</li>
<li>The prefixes <code>"v:"</code>, <code>"h:"</code>, <code>"e:"</code>, <code>"f:"</code> and <code>"m:"</code> are reserved.</li>
</ol>
<p>If we stick to this rules we are fine. Furthermore we have to consider, that the names are handled case-sensitive.</p>
<p>To actually make a custom property persistent we have to set the persistent flag in the property with</p>
<p><div class="fragment"><pre class="fragment">  mesh.property(vprop_float).set_persistent(<span class="keyword">true</span>);
</pre></div></p>
<p>Now we can use <code>IO::mesh_write()</code> to write the mesh to a file on disk. The custom properties are added after the standard properties in the file, with the name and it's binary size. These two pieces of information are evaluated when reading the file again. To successfully restore the custom properties, the mesh must have registered named properties with equal names (case-sensitive compare). Additionally, when reading the data, the number of bytes read for a property must match the provided number in the file. If the OM reader did not find a suitable named property, it will simply skip it. If the number of bytes do not match, the complete restore will be terminated and <code>IO::read_mesh()</code> will return <code>false</code>. And if the data cannot be restored, because the appropriate restore method is not available the exception std::logic_error() will be thrown.</p>
<p>Since we now know the behaviour, we need to know what kind of data can we store? Without any further effort, simply using named properties and setting the persistent flag, we can store following types</p>
<ul>
<li>bool, stored as a bitset</li>
<li>all other fundamental types except long double, (unsigned) long and size_t</li>
<li>std::string, each up to 65536 characters long</li>
<li>OpenMesh::Vec[1,2,3,4,6][c,uc,s,us,i,ui,f,d]</li>
</ul>
<p>For further reading we call these types basic types. Apparently we cannot store non-basic types, which are</p>
<ul>
<li>pointers</li>
<li>structs/classes</li>
<li>even more complex data structures, like container of containers.</li>
</ul>
<p>However there is a way to store custom types ( else we could not store std::string). Let's start with an more simple custom data. For instance we have a struct <code><a class="el" href="structMyData.html">MyData</a></code> like this</p>
 <div class="fragment"><pre class="fragment"><span class="keyword">struct </span><a class="code" href="structMyData.html">MyData</a>
{
  <span class="keywordtype">int</span>             ival;
  <span class="keywordtype">double</span>          dval;
  <span class="keywordtype">bool</span>            bval;
  OpenMesh::Vec4f vec4fval;
};
</pre></div></p>
<p>Here we keep an int, bool, double value and a vector of 4 floats, which are all basic types. Then we need to specialize the template struct OpenMesh::IO::binary&lt;&gt; within the namespace <code><a class="el" href="namespaceOpenMesh_1_1IO.html" title="This namespace contains functions for reading and writing polygonal meshes and a list of supported fi...">OpenMesh::IO</a></code> </p>
<p><div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>binary&lt;<a class="code" href="structMyData.html">MyData</a>&gt;
</pre></div></p>
<p>Remember not to use long double, (unsigned) long and size_t as basic types because of inconsistencies between 32/64bit architectures.</p>
<p>Herein we have to implement the following set of static member variables and functions:</p>
<p><div class="fragment"><pre class="fragment">      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#af78b285ab1e4310e87eeb6c7152314c1" title="Binary read a short from _is and perform byte swapping if _swap is true.">is_streamable</a> = <span class="keyword">true</span>;
      <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(<span class="keywordtype">void</span>) 
      <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(<span class="keyword">const</span> value_type&amp;) 
      <span class="keyword">static</span> <span class="keywordtype">size_t</span> store(std::ostream&amp; _os, <span class="keyword">const</span> value_type&amp; _v, <span class="keywordtype">bool</span> _swap=<span class="keyword">false</span>)
      <span class="keyword">static</span> <span class="keywordtype">size_t</span> restore( std::istream&amp; _is, value_type&amp; _v, <span class="keywordtype">bool</span> _swap=<span class="keyword">false</span>)
</pre></div></p>
<p>The flag <code>is_streamable</code> has to be set to <code>true</code>. Else the data cannot be stored at all.</p>
<h5><code>size_of</code> methods </h5>
<p>Since the size of the custom data can be static, which means we know the size at compile time, or the size of it is dynamic, which means me the size is known at runtime, we have to provide the two <code>size_of()</code> methods.</p>
<p>The first declaration is for the static case, while the second for the dynamic case. Though the static case is more simple, it is not straight forward. We cannot simply use <code>sizeof()</code> to determine the data size, because it will return the number ob bytes it needs in memory (possible 32bit alignment). Instead we need the binary size, hence we have to add up the single elements in the struct.</p>
 <div class="fragment"><pre class="fragment">        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(int)+<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)+<span class="keyword">sizeof</span>(bool)+<span class="keyword">sizeof</span>(OpenMesh::Vec4f); 
</pre></div></p>
<p>Actually we would need to sum up the single elements of the vector, but in this case we know for sure the result (4 floats make 16 bytes, which is 32bit aligned therefore <code>sizeof()</code> returns the wanted size). But keep in mind, that this a potential location for errors, when writing custom binary support.</p>
<p>The second declaration is for the dynamic case, where the custom data contains pointers or references. This static member must properly count the data, by disolving the pointers/references, if this data has to be stored as well. In the dynamic stetting the static variant cannot return the size, therefore it must return <code>IO::UnknownSize</code>.</p>
<p>In this case the dynamic variant simply returns the size by calling the static variant, as the sizes are identical for both cases.</p>
<h5><code>store</code> / <code>restore</code> </h5>
<p>For the dynamic case as for the static case, we have to make up a scheme how we would store the data. One option is to store the length of the data and then store the data itself. For instance the type <code>std::string</code> is implemented this way. (We store first the length in a 16bit word (=&gt; max. length 65536), then the characters follow. Hence <code>size_of()</code> returns 2 bytes for the length plus the actual length of the value <code>v</code>.) Since <code><a class="el" href="structMyData.html">MyData</a></code> contains only basic types we can implement the necessary methods <code>store</code> and <code>restore</code>, by simply breaking up the data into the basic types using the pre-defined store/restore methods for them:</p>
<p><div class="fragment"><pre class="fragment">      <span class="keyword">static</span> <span class="keywordtype">size_t</span> store(std::ostream&amp; _os, <span class="keyword">const</span> value_type&amp; _v, <span class="keywordtype">bool</span> _swap=<span class="keyword">false</span>)
      { 
        <span class="keywordtype">size_t</span> bytes;
        bytes  = IO::store( _os, _v.ival, _swap );
        bytes += IO::store( _os, _v.dval, _swap );
        bytes += IO::store( _os, _v.bval, _swap );
        bytes += IO::store( _os, _v.vec4fval, _swap );
        <span class="keywordflow">return</span> _os.good() ? bytes : 0;
      }
      <span class="keyword">static</span> <span class="keywordtype">size_t</span> restore( std::istream&amp; _is, value_type&amp; _v, <span class="keywordtype">bool</span> _swap=<span class="keyword">false</span>)
      { 
        <span class="keywordtype">size_t</span> bytes;
        bytes  = IO::restore( _is, _v.ival, _swap );
        bytes += IO::restore( _is, _v.dval, _swap );
        bytes += IO::restore( _is, _v.bval, _swap );
        bytes += IO::restore( _is, _v.vec4fval, _swap );
        <span class="keywordflow">return</span> _is.good() ? bytes : 0;
      }
</pre></div></p>
<p>It's very important, that the store/restore methods count the written/read bytes correctly and return the value. On error both functions must return 0.</p>
<p>A more complex situation is given with the following property</p>
 <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> std::map&lt; std::string, unsigned int &gt; MyMap;
  <a class="code" href="structOpenMesh_1_1MPropHandleT.html" title="Handle representing a mesh property.">OpenMesh::MPropHandleT&lt;MyMap&gt;</a>       mprop_map;
</pre></div></p>
<p>In this case the data contains a container, a map from strings to integer numbers. If we want to store this as well, we need to make up a scheme how the map will be stored in a sequential layout. First we store the number of elements in the map. Then, since the map has an iterator, we simply iterate over all elements and store each pair (key/value). This procedure is equal for the <code>size_of()</code>, <code>store()</code>, and <code>restore()</code> methods. For example the <code>size_of()</code> methods look like this</p>
 <div class="fragment"><pre class="fragment">      <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> UnknownSize; }
      <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(<span class="keyword">const</span> value_type&amp; _v) 
      { 
        <span class="keywordflow">if</span> (_v.empty())
          <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
        
        value_type::const_iterator it = _v.begin();
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   N     = _v.size();
        <span class="keywordtype">size_t</span>         bytes = IO::size_of(N);

        <span class="keywordflow">for</span>(;it!=_v.end(); ++it)
        {
          bytes += IO::size_of( it-&gt;first );
          bytes += IO::size_of( it-&gt;second );
        }
        <span class="keywordflow">return</span> bytes;
      }
</pre></div></p>
<p>The implementation of <code>store()</code> and <code>restore()</code> follow a similar pattern.</p>
<p>The given example program does the following steps</p>
<ol type="1">
<li>Create a mesh and generate a cube</li>
<li>Add a few custom properties</li>
<li>Fill them with test data</li>
<li>Make the properties persistent</li>
<li>Store mesh in a file named 'persistent-check.om'</li>
<li>Clear the mesh</li>
<li>Restore mesh</li>
<li>Check the content on equality with the test data.</li>
</ol>
<p>Since the example is a little bit longer than usual the source is in several files. The main program is in <code>persistence.cc</code>, the cube generator in <code>generate_cube.hh</code>, <code>stats.hh</code> provides little tools to display information about the mesh and the properties, the file <code>fill_props.hh</code> providing the test data, and <code>int2roman.hh/</code>.cc, which is used in fill_props.hh. All necessary parts are in <code>persistence.cc</code>, which is displayed in full length below. For the other files please have a look in the directory <code>OpenMesh/Doc/Tutorial/09-persistence/</code>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;map&gt;</span>
<span class="comment">// -------------------- OpenMesh</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/PolyMesh_ArrayKernelT.hh&gt;</span>
<span class="comment">// -------------------- little helper</span>
<span class="preprocessor">#include &quot;generate_cube.hh&quot;</span>
<span class="preprocessor">#include &quot;stats.hh&quot;</span>
<span class="preprocessor">#include &quot;fill_props.hh&quot;</span>

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="comment">// Set to 1 to use an PolyMesh type.</span>
<span class="preprocessor">#define UsePolyMesh 1</span>
<span class="preprocessor"></span>
<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keyword">using namespace </span>OpenMesh;

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keyword">typedef</span> TriMesh_ArrayKernelT&lt;&gt;  TriMesh;
<span class="keyword">typedef</span> PolyMesh_ArrayKernelT&lt;&gt; PolyMesh;

<span class="preprocessor">#if UsePolyMesh</span>
<span class="preprocessor"></span><span class="keyword">typedef</span> PolyMesh Mesh;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="keyword">typedef</span> TriMesh Mesh;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="keyword">struct </span><a class="code" href="structMyData.html">MyData</a>
{
  <span class="keywordtype">int</span>             ival;
  <span class="keywordtype">double</span>          dval;
  <span class="keywordtype">bool</span>            bval;
  OpenMesh::Vec4f vec4fval;

  <a class="code" href="structMyData.html">MyData</a>()
    : ival(0), dval(0.0), bval(false)
  { }

  <a class="code" href="structMyData.html">MyData</a>( <span class="keyword">const</span> <a class="code" href="structMyData.html">MyData</a>&amp; _cpy )
    : ival(_cpy.ival), dval(_cpy.dval), bval(_cpy.bval), 
      vec4fval(_cpy.vec4fval)
  { }


  <span class="comment">// ---------- assignment</span>

  <a class="code" href="structMyData.html">MyData</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="structMyData.html">MyData</a>&amp; _rhs) 
  { 
    ival = _rhs.ival; 
    dval = _rhs.dval;
    bval = _rhs.bval;
    vec4fval = _rhs.vec4fval;
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <a class="code" href="structMyData.html">MyData</a>&amp; operator = (<span class="keywordtype">int</span>    _rhs) { ival = _rhs; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
  <a class="code" href="structMyData.html">MyData</a>&amp; operator = (<span class="keywordtype">double</span> _rhs) { dval = _rhs; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
  <a class="code" href="structMyData.html">MyData</a>&amp; operator = (<span class="keywordtype">bool</span>   _rhs) { bval = _rhs; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
  <a class="code" href="structMyData.html">MyData</a>&amp; operator = (<span class="keyword">const</span> OpenMesh::Vec4f&amp; _rhs) 
  { vec4fval = _rhs; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }


  <span class="comment">// ---------- comparison</span>

  <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <a class="code" href="structMyData.html">MyData</a>&amp; _rhs)<span class="keyword"> const</span>
<span class="keyword">  </span>{ 
    <span class="keywordflow">return</span> ival == _rhs.ival
      &amp;&amp;   dval == _rhs.dval
      &amp;&amp;   bval == _rhs.bval
      &amp;&amp;   vec4fval == _rhs.vec4fval;
  }

  <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="structMyData.html">MyData</a>&amp; _rhs)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == _rhs); }

};

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keyword">typedef</span> std::map&lt; std::string, unsigned int &gt; MyMap;


<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="keyword">namespace </span>OpenMesh {
  <span class="keyword">namespace </span>IO {

    <span class="comment">// support persistence for struct MyData</span>

    <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>binary&lt;<a class="code" href="structMyData.html">MyData</a>&gt;
    {
      <span class="keyword">typedef</span> <a class="code" href="structMyData.html">MyData</a> value_type;

      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_streamable = <span class="keyword">true</span>;

      <span class="comment">// return binary size of the value</span>

      <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(<span class="keywordtype">void</span>) 
      { 
        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(int)+<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)+<span class="keyword">sizeof</span>(bool)+<span class="keyword">sizeof</span>(OpenMesh::Vec4f); 
      }

      <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(<span class="keyword">const</span> value_type&amp;) 
      { 
        <span class="keywordflow">return</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(); 
      }

      <span class="keyword">static</span> <span class="keywordtype">size_t</span> store(std::ostream&amp; _os, <span class="keyword">const</span> value_type&amp; _v, <span class="keywordtype">bool</span> _swap=<span class="keyword">false</span>)
      { 
        <span class="keywordtype">size_t</span> bytes;
        bytes  = IO::store( _os, _v.ival, _swap );
        bytes += IO::store( _os, _v.dval, _swap );
        bytes += IO::store( _os, _v.bval, _swap );
        bytes += IO::store( _os, _v.vec4fval, _swap );
        <span class="keywordflow">return</span> _os.good() ? bytes : 0;
      }

      <span class="keyword">static</span> <span class="keywordtype">size_t</span> restore( std::istream&amp; _is, value_type&amp; _v, <span class="keywordtype">bool</span> _swap=<span class="keyword">false</span>)
      { 
        <span class="keywordtype">size_t</span> bytes;
        bytes  = IO::restore( _is, _v.ival, _swap );
        bytes += IO::restore( _is, _v.dval, _swap );
        bytes += IO::restore( _is, _v.bval, _swap );
        bytes += IO::restore( _is, _v.vec4fval, _swap );
        <span class="keywordflow">return</span> _is.good() ? bytes : 0;
      }
    };


    <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>binary&lt; MyMap &gt;
    {
      <span class="keyword">typedef</span> MyMap value_type;

      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_streamable = <span class="keyword">true</span>;

      <span class="comment">// return generic binary size of self, if known</span>
      <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> UnknownSize; }

      <span class="comment">// return binary size of the value</span>
      <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceOpenMesh_1_1IO.html#ad74cf9a384f91f82b907be4eaff86882" title="Binary read a short from _is and perform byte swapping if _swap is true.">size_of</a>(<span class="keyword">const</span> value_type&amp; _v) 
      { 
        <span class="keywordflow">if</span> (_v.empty())
          <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
        
        value_type::const_iterator it = _v.begin();
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   N     = _v.size();
        <span class="keywordtype">size_t</span>         bytes = IO::size_of(N);

        <span class="keywordflow">for</span>(;it!=_v.end(); ++it)
        {
          bytes += IO::size_of( it-&gt;first );
          bytes += IO::size_of( it-&gt;second );
        }
        <span class="keywordflow">return</span> bytes;
      }

      <span class="keyword">static</span> 
      <span class="keywordtype">size_t</span> store(std::ostream&amp; _os, <span class="keyword">const</span> value_type&amp; _v, <span class="keywordtype">bool</span> _swap=<span class="keyword">false</span>)
      { 
        <span class="keywordtype">size_t</span>   bytes = 0;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = _v.size();

        value_type::const_iterator it = _v.begin();

        bytes += IO::store( _os, N, _swap );

        <span class="keywordflow">for</span> (; it != _v.end() &amp;&amp; _os.good(); ++it)
        {
          bytes += IO::store( _os, it-&gt;first, _swap );
          bytes += IO::store( _os, it-&gt;second, _swap );
        }
        <span class="keywordflow">return</span> _os.good() ? bytes : 0;
      }

      <span class="keyword">static</span> 
      <span class="keywordtype">size_t</span> restore( std::istream&amp; _is, value_type&amp; _v, <span class="keywordtype">bool</span> _swap=<span class="keyword">false</span>)
      { 
        <span class="keywordtype">size_t</span>   bytes = 0;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = 0;

        _v.clear();

        bytes += IO::restore( _is, N, _swap );

        value_type::iterator   it = _v.begin();
        std::string key;
        <span class="keywordtype">size_t</span>      val;

        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;N &amp;&amp; _is.good(); ++i)
        {          
          bytes += IO::restore( _is, key, _swap );
          bytes += IO::restore( _is, val, _swap );
          _v[key] = val;
        }
        <span class="keywordflow">return</span> _is.good() ? bytes : 0;
      }
    };

  }
}

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
  <span class="comment">//</span>
  Mesh mesh;

  
  <span class="comment">// generate a geometry</span>
  generate_cube&lt;Mesh&gt;(mesh);


  <span class="comment">// should display 8 vertices, 18/12 edges, 12/6 faces (Tri/Poly)</span>
  mesh_stats(mesh);


  <span class="comment">// print out information about properties</span>
  mesh_property_stats(mesh);


  std::cout &lt;&lt; <span class="stringliteral">&quot;Define some custom properties..\n&quot;</span>;

  <a class="code" href="structOpenMesh_1_1VPropHandleT.html">OpenMesh::VPropHandleT&lt;float&gt;</a>       vprop_float;
  <a class="code" href="structOpenMesh_1_1EPropHandleT.html" title="Handle representing an edge property.">OpenMesh::EPropHandleT&lt;bool&gt;</a>        eprop_bool;
  <a class="code" href="structOpenMesh_1_1FPropHandleT.html" title="Handle representing a face property.">OpenMesh::FPropHandleT&lt;std::string&gt;</a> fprop_string;
  <a class="code" href="structOpenMesh_1_1HPropHandleT.html" title="Handle representing a halfedge property.">OpenMesh::HPropHandleT&lt;MyData&gt;</a>      hprop_mydata;
  <a class="code" href="structOpenMesh_1_1MPropHandleT.html" title="Handle representing a mesh property.">OpenMesh::MPropHandleT&lt;MyMap&gt;</a>       mprop_map;
    
  std::cout &lt;&lt; <span class="stringliteral">&quot;.. and registrate them at the mesh object.\n&quot;</span>;

  mesh.add_property(vprop_float,  <span class="stringliteral">&quot;vprop_float&quot;</span>);
  mesh.add_property(eprop_bool,   <span class="stringliteral">&quot;eprop_bool&quot;</span>);
  mesh.add_property(fprop_string, <span class="stringliteral">&quot;fprop_string&quot;</span>);
  mesh.add_property(hprop_mydata, <span class="stringliteral">&quot;hprop_mydata&quot;</span>);
  mesh.add_property(mprop_map,    <span class="stringliteral">&quot;mprop_map&quot;</span>);


  mesh_property_stats(mesh);


  std::cout &lt;&lt; <span class="stringliteral">&quot;Now let&#39;s fill the props..\n&quot;</span>;

  fill_props(mesh, vprop_float);
  fill_props(mesh, eprop_bool);
  fill_props(mesh, fprop_string);
  fill_props(mesh, hprop_mydata);
  fill_props(mesh, mprop_map);


  std::cout &lt;&lt; <span class="stringliteral">&quot;Check props..\n&quot;</span>;
<span class="preprocessor">#define CHK_PROP( PH ) \</span>
<span class="preprocessor">  std::cout &lt;&lt; &quot;  &quot; &lt;&lt; #PH &lt;&lt; &quot; &quot; \</span>
<span class="preprocessor">            &lt;&lt; (fill_props(mesh, PH, true)?&quot;ok\n&quot;:&quot;error\n&quot;)</span>
<span class="preprocessor"></span>
  CHK_PROP(vprop_float);
  CHK_PROP(eprop_bool);
  CHK_PROP(fprop_string);
  CHK_PROP(hprop_mydata);
  CHK_PROP(mprop_map);
<span class="preprocessor">#undef CHK_PROP</span>
<span class="preprocessor"></span>

  std::cout &lt;&lt; <span class="stringliteral">&quot;Set persistent flag..\n&quot;</span>;
<span class="preprocessor">#define SET_PERS( PH ) \</span>
<span class="preprocessor">    mesh.property(PH).set_persistent(true); \</span>
<span class="preprocessor">    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; #PH &lt;&lt; &quot; &quot; \</span>
<span class="preprocessor">              &lt;&lt; (mesh.property(PH).persistent()?&quot;ok\n&quot;:&quot;failed!\n&quot;)</span>
<span class="preprocessor"></span>
  mesh.property(vprop_float).set_persistent(<span class="keyword">true</span>);
  std::cout &lt;&lt; <span class="stringliteral">&quot;  vprop_float &quot;</span>
            &lt;&lt; (mesh.property(vprop_float).persistent()?<span class="stringliteral">&quot;ok\n&quot;</span>:<span class="stringliteral">&quot;failed!\n&quot;</span>);
  
  SET_PERS( eprop_bool );
  SET_PERS( fprop_string );
  SET_PERS( hprop_mydata );
  mesh.mproperty(mprop_map).set_persistent(<span class="keyword">true</span>);
  std::cout &lt;&lt; <span class="stringliteral">&quot;  mprop_map &quot;</span>
            &lt;&lt; (mesh.mproperty(mprop_map).persistent()?<span class="stringliteral">&quot;ok\n&quot;</span>:<span class="stringliteral">&quot;failed!\n&quot;</span>);
 

  std::cout &lt;&lt; <span class="stringliteral">&quot;Write mesh..&quot;</span>;
  <span class="keywordflow">if</span> (IO::write_mesh( mesh, <span class="stringliteral">&quot;persistence-check.om&quot;</span> ))
    std::cout &lt;&lt; <span class="stringliteral">&quot;  ok\n&quot;</span>;
  <span class="keywordflow">else</span>
  {
    std::cout &lt;&lt; <span class="stringliteral">&quot;  failed\n&quot;</span>;
    <span class="keywordflow">return</span> 1;
  }


  std::cout &lt;&lt; <span class="stringliteral">&quot;Clear mesh\n&quot;</span>;
  mesh.clear();
  mesh_stats(mesh, <span class="stringliteral">&quot;  &quot;</span>);
  

  std::cout &lt;&lt; <span class="stringliteral">&quot;Read back mesh..&quot;</span>;
  <span class="keywordflow">try</span>
  {
    <span class="keywordflow">if</span> (IO::read_mesh( mesh, <span class="stringliteral">&quot;persistence-check.om&quot;</span> ))
      std::cout &lt;&lt; <span class="stringliteral">&quot;  ok\n&quot;</span>;
    <span class="keywordflow">else</span>
    {
      std::cout &lt;&lt; <span class="stringliteral">&quot;  failed!\n&quot;</span>;
      <span class="keywordflow">return</span> 1;
    }
    mesh_stats(mesh, <span class="stringliteral">&quot;  &quot;</span>);
  }
  <span class="keywordflow">catch</span>( std::exception &amp;x )
  {
    std::cerr &lt;&lt; x.what() &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }


  std::cout &lt;&lt; <span class="stringliteral">&quot;Check props..\n&quot;</span>;
<span class="preprocessor">#define CHK_PROP( PH ) \</span>
<span class="preprocessor">  std::cout &lt;&lt; &quot;  &quot; &lt;&lt; #PH &lt;&lt; &quot; &quot; \</span>
<span class="preprocessor">            &lt;&lt; (fill_props(mesh, PH, true)?&quot;ok\n&quot;:&quot;error\n&quot;)</span>
<span class="preprocessor"></span>  CHK_PROP(vprop_float);
  CHK_PROP(eprop_bool);
  CHK_PROP(fprop_string);
  CHK_PROP(hprop_mydata);
  CHK_PROP(mprop_map);
<span class="preprocessor">#undef CHK_PROP</span>
<span class="preprocessor"></span>
  <span class="keywordflow">return</span> 0;
}

<span class="comment">// end of file</span>
<span class="comment">// ============================================================================</span>
</pre></div> </div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
