<html>
    <head>
      <title>OpenMesh: Using STL algorithms</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">OpenMesh Documentation</a>      </li>
      <li><a class="el" href="tutorial.html">Tutorials (code examples)</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Using STL algorithms </h1>  </div>
</div>
<div class="contents">
<p>Since the OpenMesh iterators are (almost) conformant to STL iterators, one can apply the STL algorithms on meshes.</p>
<p>The following example shows how to use the STL <code>for_each</code> construct, since it is easier to read and may be more efficient than hand-written loops.</p>
<p>We will define a class which provides the smoothing algorithm, hence define a reusable component. The class must be template class because there is no such thing as a class OpenMesh, but many different types of OpenMesh:</p>
 <div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh&gt; <span class="keyword">class </span><a class="code" href="classSmootherT.html">SmootherT</a>
</pre></div></p>
<p>The class <a class="el" href="classSmootherT.html">SmootherT</a> has two functors, one that computes the barycenter for a given vertex, and a second that sets the vertex position to the corresponding barycenter. A functor is simply a class with a function <code>operator()(...)</code>. The first functor <code>ComputeCOG</code> computes the barycenter and stores it in a custom vertex property <code>cog_:</code> </p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> operator()(<span class="keyword">typename</span> Mesh::Vertex&amp; _v)
    {
      <span class="keyword">typename</span> Mesh::VertexHandle      vh( mesh_.handle(_v) );
      <span class="keyword">typename</span> Mesh::VertexVertexIter  vv_it;
      <span class="keyword">typename</span> Mesh::Scalar            valence(0.0);
    
      mesh_.property(cog_, vh) = <span class="keyword">typename</span> Mesh::Point(0.0, 0.0, 0.0);

      <span class="keywordflow">for</span> (vv_it=mesh_.vv_iter(vh); vv_it; ++vv_it)
      {
        mesh_.property(cog_, vh) += mesh_.point( vv_it );
        ++valence;
      }

      mesh_.property(cog_, mesh_.handle(_v) ) /= valence;
    }
</pre></div></p>
<p>Note, that <code>ComputeCOG</code> needs to have access to the mesh object and the property handle. Here, both are references to member variables of the smoother object.</p>
<p>The second functor <code>class</code> <code>SetCOG</code>, which sets the vertex position, is constructed analogical.</p>
<p>Using these functors and <code>std::for_each</code> from the STL the smoothing algorithm can be realized in a member function of <code><a class="el" href="classSmootherT.html">SmootherT</a>:</code> </p>
 <div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> smooth(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _iterations)
  {
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; _iterations; ++i)
    {
      std::for_each(mesh_.vertices_begin(), 
                    mesh_.vertices_end(), 
                    ComputeCOG(mesh_, cog_));

      std::for_each(mesh_.vertices_begin(), 
                    mesh_.vertices_end(), 
                    SetCOG(mesh_, cog_));
    }
  }
</pre></div></p>
<p><br/>
The complete example looks like this:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Utils/Property.hh&gt;</span>

<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh&gt; <span class="keyword">class </span><a class="code" href="classSmootherT.html">SmootherT</a>
{
<span class="keyword">public</span>:

  <span class="keyword">typedef</span> <span class="keyword">typename</span> Mesh::Point            cog_t;
  <span class="keyword">typedef</span> <a class="code" href="structOpenMesh_1_1VPropHandleT.html">OpenMesh::VPropHandleT&lt; cog_t &gt;</a> Property_cog;

<span class="keyword">public</span>:

  <span class="comment">// construct with a given mesh</span>
  <a class="code" href="classSmootherT.html">SmootherT</a>(Mesh&amp; _mesh) 
    : mesh_(_mesh)
  { 
    mesh_.add_property( cog_ );
  }

  ~<a class="code" href="classSmootherT.html">SmootherT</a>()
  {
    mesh_.remove_property( cog_ );
  }

  <span class="comment">// smooth mesh _iterations times</span>
  <span class="keywordtype">void</span> smooth(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _iterations)
  {
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; _iterations; ++i)
    {
      std::for_each(mesh_.vertices_begin(), 
                    mesh_.vertices_end(), 
                    ComputeCOG(mesh_, cog_));

      std::for_each(mesh_.vertices_begin(), 
                    mesh_.vertices_end(), 
                    SetCOG(mesh_, cog_));
    }
  }


<span class="keyword">private</span>:


  <span class="comment">//--- private classes ---</span>

  <span class="keyword">class </span>ComputeCOG
  {
  <span class="keyword">public</span>:
    ComputeCOG(Mesh&amp; _mesh, Property_cog&amp; _cog) 
      : mesh_(_mesh), cog_(_cog)
    {}

    <span class="keywordtype">void</span> operator()(<span class="keyword">typename</span> Mesh::Vertex&amp; _v)
    {
      <span class="keyword">typename</span> Mesh::VertexHandle      vh( mesh_.handle(_v) );
      <span class="keyword">typename</span> Mesh::VertexVertexIter  vv_it;
      <span class="keyword">typename</span> Mesh::Scalar            valence(0.0);
    
      mesh_.property(cog_, vh) = <span class="keyword">typename</span> Mesh::Point(0.0, 0.0, 0.0);

      <span class="keywordflow">for</span> (vv_it=mesh_.vv_iter(vh); vv_it; ++vv_it)
      {
        mesh_.property(cog_, vh) += mesh_.point( vv_it );
        ++valence;
      }

      mesh_.property(cog_, mesh_.handle(_v) ) /= valence;
    }

  <span class="keyword">private</span>:
    Mesh&amp;         mesh_;
    Property_cog&amp; cog_;
  };


  <span class="keyword">class </span>SetCOG
  {
  <span class="keyword">public</span>:
    SetCOG(Mesh&amp; _mesh, Property_cog&amp; _cog) 
      : mesh_(_mesh), cog_(_cog)
    {}

    <span class="keywordtype">void</span> operator()(<span class="keyword">typename</span> Mesh::Vertex&amp; _v)
    {
      <span class="keyword">typename</span> Mesh::VertexHandle vh(mesh_.handle(_v));

      <span class="keywordflow">if</span> (!mesh_.is_boundary(vh))
        mesh_.set_point( vh, mesh_.property(cog_, vh) );
    }

  <span class="keyword">private</span>:

    Mesh&amp;         mesh_;
    Property_cog&amp; cog_;
  };


  <span class="comment">//--- private elements ---</span>

  Mesh&amp;        mesh_;
  Property_cog cog_;
};

<span class="preprocessor">#endif</span>
</pre></div><p><br/>
and</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="comment">// -------------------- OpenMesh</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh&gt;</span>
<span class="comment">// -------------------- </span>
<span class="preprocessor">#include &quot;smooth_algo.hh&quot;</span>


<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="keyword">struct </span><a class="code" href="structMyTraits.html">MyTraits</a> : <span class="keyword">public</span> OpenMesh::DefaultTraits
{
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#a72688ff15a275a41a98159ce72eaab4f" title="Macro for defining the halfedge attributes. See Specifying your MyMesh.">HalfedgeAttributes</a>(<a class="code" href="namespaceOpenMesh_1_1Attributes.html#ab78a93560926cd2f9958cb028f7ea96dafaaebe1808b5cce96ad4e19df471d58a" title="Add storage for previous halfedge (halfedges). The bit is set by default in the DefaultTraits.">OpenMesh::Attributes::PrevHalfedge</a>);
};

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html" title="Triangle mesh based on the ArrayKernel.">OpenMesh::TriMesh_ArrayKernelT&lt;MyTraits&gt;</a>  MyMesh;


<span class="comment">// ----------------------------------------------------------------------------</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh  mesh;


  <span class="comment">// check command line options</span>
  <span class="keywordflow">if</span> (argc != 4) 
  {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage:  &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; #iterations  infile  outfile\n&quot;</span>;
    <span class="keywordflow">return</span> 1;
  }


  <span class="comment">// read mesh from stdin</span>
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#ae4b7d0255a084aca13f5c7a553b86e72" title="Read a mesh from file _filename.">OpenMesh::IO::read_mesh</a>(mesh, argv[2]) )
  {
     std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: Cannot read mesh from &quot;</span> &lt;&lt; argv[2] &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 1;
  }


  <span class="comment">// smoothing mesh argv[1] times</span>
  <a class="code" href="classSmootherT.html">SmootherT&lt;MyMesh&gt;</a> smoother(mesh);
  smoother.smooth(atoi(argv[1]));


  <span class="comment">// write mesh to stdout</span>
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#ab6b68cf71ede53756653b31bd0e292a5" title="Write a mesh to the file _filename.">OpenMesh::IO::write_mesh</a>(mesh, argv[3]) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: cannot write mesh to &quot;</span> &lt;&lt; argv[3] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }
  <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
