<html>
    <head>
      <title>OpenMesh: VectorT&lt; Scalar, N &gt; Class Template Reference</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>VectorT&lt; Scalar, N &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="VectorT" -->
<p><a href="classVectorT-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e732770fcb2ed625ac0f46b271ea5e0"></a><!-- doxytag: member="VectorT::value_type" ref="a3e732770fcb2ed625ac0f46b271ea5e0" args="" -->
typedef Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a3e732770fcb2ed625ac0f46b271ea5e0">value_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of the scalar used in this template <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0546f0353e5426d0813d2cc39379517a"></a><!-- doxytag: member="VectorT::vector_type" ref="a0546f0353e5426d0813d2cc39379517a" args="" -->
typedef <a class="el" href="classVectorT.html">VectorT</a>&lt; Scalar, N &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a0546f0353e5426d0813d2cc39379517a">vector_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">type of this vector <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada1d3d22f54c2934ec6bfba30ec76a13"></a><!-- doxytag: member="VectorT::VectorT" ref="ada1d3d22f54c2934ec6bfba30ec76a13" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ada1d3d22f54c2934ec6bfba30ec76a13">VectorT</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default constructor creates uninitialized values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a520dfe1877f57193b09a4b1dc1032257"></a><!-- doxytag: member="VectorT::VectorT" ref="a520dfe1877f57193b09a4b1dc1032257" args="(const Scalar &amp;v)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a520dfe1877f57193b09a4b1dc1032257">VectorT</a> (const Scalar &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special constructor for 1D vectors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee5b1bdb10345393bff43f10821e0217"></a><!-- doxytag: member="VectorT::VectorT" ref="aee5b1bdb10345393bff43f10821e0217" args="(const Scalar &amp;v0, const Scalar &amp;v1)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#aee5b1bdb10345393bff43f10821e0217">VectorT</a> (const Scalar &amp;v0, const Scalar &amp;v1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special constructor for 2D vectors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a639881e5f85599aa24f5df35bc438ef8"></a><!-- doxytag: member="VectorT::VectorT" ref="a639881e5f85599aa24f5df35bc438ef8" args="(const Scalar &amp;v0, const Scalar &amp;v1, const Scalar &amp;v2)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a639881e5f85599aa24f5df35bc438ef8">VectorT</a> (const Scalar &amp;v0, const Scalar &amp;v1, const Scalar &amp;v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special constructor for 3D vectors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a424d666c17b774c0dedeef3e0df923c2"></a><!-- doxytag: member="VectorT::VectorT" ref="a424d666c17b774c0dedeef3e0df923c2" args="(const Scalar &amp;v0, const Scalar &amp;v1, const Scalar &amp;v2, const Scalar &amp;v3)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a424d666c17b774c0dedeef3e0df923c2">VectorT</a> (const Scalar &amp;v0, const Scalar &amp;v1, const Scalar &amp;v2, const Scalar &amp;v3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special constructor for 4D vectors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03032d8bc499b2414bf40f8151aefa85"></a><!-- doxytag: member="VectorT::VectorT" ref="a03032d8bc499b2414bf40f8151aefa85" args="(const Scalar &amp;v0, const Scalar &amp;v1, const Scalar &amp;v2, const Scalar &amp;v3, const Scalar &amp;v4)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a03032d8bc499b2414bf40f8151aefa85">VectorT</a> (const Scalar &amp;v0, const Scalar &amp;v1, const Scalar &amp;v2, const Scalar &amp;v3, const Scalar &amp;v4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special constructor for 5D vectors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a144a6a86022abd3f281db36bf66c02c9"></a><!-- doxytag: member="VectorT::VectorT" ref="a144a6a86022abd3f281db36bf66c02c9" args="(const Scalar &amp;v0, const Scalar &amp;v1, const Scalar &amp;v2, const Scalar &amp;v3, const Scalar &amp;v4, const Scalar &amp;v5)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a144a6a86022abd3f281db36bf66c02c9">VectorT</a> (const Scalar &amp;v0, const Scalar &amp;v1, const Scalar &amp;v2, const Scalar &amp;v3, const Scalar &amp;v4, const Scalar &amp;v5)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">special constructor for 6D vectors <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95125d93a1d3f168c5e8d01b829f5c5e"></a><!-- doxytag: member="VectorT::VectorT" ref="a95125d93a1d3f168c5e8d01b829f5c5e" args="(const Scalar _values[N])" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a95125d93a1d3f168c5e8d01b829f5c5e">VectorT</a> (const Scalar _values[N])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct from a value array (explicit) <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6db48e028e2500237c706b4510080df8"></a><!-- doxytag: member="VectorT::VectorT" ref="a6db48e028e2500237c706b4510080df8" args="(const VectorT&lt; otherScalarType, N &gt; &amp;_rhs)" -->
template&lt;typename otherScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorT.html#a6db48e028e2500237c706b4510080df8">VectorT</a> (const <a class="el" href="classVectorT.html">VectorT</a>&lt; otherScalarType, N &gt; &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy &amp; cast constructor (explicit) <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8c97ceb1678d314e55bc86f1a8d8009"></a><!-- doxytag: member="VectorT::operator=" ref="ae8c97ceb1678d314e55bc86f1a8d8009" args="(const VectorT&lt; otherScalarType, N &gt; &amp;_rhs)" -->
template&lt;typename otherScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorT.html#ae8c97ceb1678d314e55bc86f1a8d8009">operator=</a> (const <a class="el" href="classVectorT.html">VectorT</a>&lt; otherScalarType, N &gt; &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cast from vector with a different scalar type <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a316aa3e33ba9a5f6e3b2a0bb836e41b8"></a><!-- doxytag: member="VectorT::data" ref="a316aa3e33ba9a5f6e3b2a0bb836e41b8" args="()" -->
Scalar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a316aa3e33ba9a5f6e3b2a0bb836e41b8">data</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">access to Scalar array <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a447feba606a7c8c13670794fa8ada151"></a><!-- doxytag: member="VectorT::data" ref="a447feba606a7c8c13670794fa8ada151" args="() const " -->
const Scalar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a447feba606a7c8c13670794fa8ada151">data</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">access to const Scalar array <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab286d17965877f488b002d8001a75014"></a><!-- doxytag: member="VectorT::operator[]" ref="ab286d17965877f488b002d8001a75014" args="(size_t _i)" -->
Scalar &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ab286d17965877f488b002d8001a75014">operator[]</a> (size_t _i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get i'th element read-write <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff404699ab2fbc45b3987e20218617a"></a><!-- doxytag: member="VectorT::operator[]" ref="a6ff404699ab2fbc45b3987e20218617a" args="(size_t _i) const " -->
const Scalar &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a6ff404699ab2fbc45b3987e20218617a">operator[]</a> (size_t _i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get i'th element read-only <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4bd80a1336d8099714429d75cc752f2"></a><!-- doxytag: member="VectorT::operator==" ref="ae4bd80a1336d8099714429d75cc752f2" args="(const vector_type &amp;_rhs) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ae4bd80a1336d8099714429d75cc752f2">operator==</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab01c20ddef0be72f3b5dab7a07b62e56"></a><!-- doxytag: member="VectorT::operator!=" ref="ab01c20ddef0be72f3b5dab7a07b62e56" args="(const vector_type &amp;_rhs) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ab01c20ddef0be72f3b5dab7a07b62e56">operator!=</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise comparison <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca04d0fbc435e8b3146d1e91fbc560cf"></a><!-- doxytag: member="VectorT::operator*=" ref="aca04d0fbc435e8b3146d1e91fbc560cf" args="(const Scalar &amp;_s)" -->
<a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#aca04d0fbc435e8b3146d1e91fbc560cf">operator*=</a> (const Scalar &amp;_s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise self-multiplication with scalar <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a0b99c174141169827de8da5326f40e46">operator/=</a> (const Scalar &amp;_s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise self-division by scalar  <a href="#a0b99c174141169827de8da5326f40e46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a752d6939daf34a8ea020738ca53ab936"></a><!-- doxytag: member="VectorT::operator*" ref="a752d6939daf34a8ea020738ca53ab936" args="(const Scalar &amp;_s) const " -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a752d6939daf34a8ea020738ca53ab936">operator*</a> (const Scalar &amp;_s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise multiplication with scalar <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1eae102536b78c035a880f9029f83bd"></a><!-- doxytag: member="VectorT::operator/" ref="ad1eae102536b78c035a880f9029f83bd" args="(const Scalar &amp;_s) const " -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ad1eae102536b78c035a880f9029f83bd">operator/</a> (const Scalar &amp;_s) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise division by with scalar <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c1af7e204683b7b9941aae52bbf048"></a><!-- doxytag: member="VectorT::operator*=" ref="ad4c1af7e204683b7b9941aae52bbf048" args="(const vector_type &amp;_rhs)" -->
<a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ad4c1af7e204683b7b9941aae52bbf048">operator*=</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise self-multiplication <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a343c96dccb0cc83c5265c919405c24f8"></a><!-- doxytag: member="VectorT::operator/=" ref="a343c96dccb0cc83c5265c919405c24f8" args="(const vector_type &amp;_rhs)" -->
<a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a343c96dccb0cc83c5265c919405c24f8">operator/=</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise self-division <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af70ea9351e884580507b82bff5d7f077"></a><!-- doxytag: member="VectorT::operator&#45;=" ref="af70ea9351e884580507b82bff5d7f077" args="(const vector_type &amp;_rhs)" -->
<a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#af70ea9351e884580507b82bff5d7f077">operator-=</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector difference from this <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7868b96521994e3fbf63e20df453d76"></a><!-- doxytag: member="VectorT::operator+=" ref="ac7868b96521994e3fbf63e20df453d76" args="(const vector_type &amp;_rhs)" -->
<a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ac7868b96521994e3fbf63e20df453d76">operator+=</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector self-addition <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af60908e6f23702b7171b866d660c56e1"></a><!-- doxytag: member="VectorT::operator*" ref="af60908e6f23702b7171b866d660c56e1" args="(const vector_type &amp;_v) const " -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#af60908e6f23702b7171b866d660c56e1">operator*</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise vector multiplication <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79894968bcb172dfd8cd7814155869e"></a><!-- doxytag: member="VectorT::operator/" ref="ac79894968bcb172dfd8cd7814155869e" args="(const vector_type &amp;_v) const " -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ac79894968bcb172dfd8cd7814155869e">operator/</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise vector division <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3905d8e63125bd777a4daea38a6e38e"></a><!-- doxytag: member="VectorT::operator+" ref="ab3905d8e63125bd777a4daea38a6e38e" args="(const vector_type &amp;_v) const " -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ab3905d8e63125bd777a4daea38a6e38e">operator+</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise vector addition <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a717b9bc6839d03d4429f03beabfea053"></a><!-- doxytag: member="VectorT::operator&#45;" ref="a717b9bc6839d03d4429f03beabfea053" args="(const vector_type &amp;_v) const " -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a717b9bc6839d03d4429f03beabfea053">operator-</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise vector difference <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16eb82520e8b201220393da5331b5158"></a><!-- doxytag: member="VectorT::operator&#45;" ref="a16eb82520e8b201220393da5331b5158" args="(void) const " -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a16eb82520e8b201220393da5331b5158">operator-</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unary minus <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorT.html">VectorT</a>&lt; Scalar, 3 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a551a537492a30ae308689fc079a27218">operator%</a> (const <a class="el" href="classVectorT.html">VectorT</a>&lt; Scalar, 3 &gt; &amp;_rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cross product: only defined for Vec3* as specialization  <a href="#a551a537492a30ae308689fc079a27218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a79eb5b7cfed6a4130e8226a2e15dede7">operator|</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute scalar product  <a href="#a79eb5b7cfed6a4130e8226a2e15dede7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abfe73fe89a0ee34a70019de90a042dfb"></a><!-- doxytag: member="VectorT::apply" ref="abfe73fe89a0ee34a70019de90a042dfb" args="(const Functor &amp;_func) const " -->
template&lt;typename Functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorT.html#abfe73fe89a0ee34a70019de90a042dfb">apply</a> (const Functor &amp;_func) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise apply function object with Scalar operator()(Scalar). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8e719cc4e5e154ad42d00657513a7f7"></a><!-- doxytag: member="VectorT::vectorize" ref="ad8e719cc4e5e154ad42d00657513a7f7" args="(const Scalar &amp;_s)" -->
<a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ad8e719cc4e5e154ad42d00657513a7f7">vectorize</a> (const Scalar &amp;_s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">store the same value in each component (e.g. to clear all entries) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5c1d9265a60c110310be1fd5350a77d"></a><!-- doxytag: member="VectorT::operator&lt;" ref="ad5c1d9265a60c110310be1fd5350a77d" args="(const vector_type &amp;_rhs) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ad5c1d9265a60c110310be1fd5350a77d">operator&lt;</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lexicographical comparison <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Euclidean norm calculations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd519e00460f66b232684b91c42e2cc0b"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2b351f903d1e89d46c65a52eb1ba6dc"></a><!-- doxytag: member="VectorT::norm" ref="ab2b351f903d1e89d46c65a52eb1ba6dc" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ab2b351f903d1e89d46c65a52eb1ba6dc">norm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute euclidean norm <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a937079fb74773cae30342ae3633c27c7"></a><!-- doxytag: member="VectorT::length" ref="a937079fb74773cae30342ae3633c27c7" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a937079fb74773cae30342ae3633c27c7">length</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute euclidean norm <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24a42c20c87d0027d5f2772060cfcb6e"></a><!-- doxytag: member="VectorT::sqrnorm" ref="a24a42c20c87d0027d5f2772060cfcb6e" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a24a42c20c87d0027d5f2772060cfcb6e">sqrnorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute squared euclidean norm <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af58eb524656303d165ebd38b66ace6c7"></a><!-- doxytag: member="VectorT::normalize" ref="af58eb524656303d165ebd38b66ace6c7" args="()" -->
<a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#af58eb524656303d165ebd38b66ace6c7">normalize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">normalize vector, return normalized vector <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad36f0b5dcd0a814a95ca597214c0a455"></a><!-- doxytag: member="VectorT::normalize_cond" ref="ad36f0b5dcd0a814a95ca597214c0a455" args="()" -->
<a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ad36f0b5dcd0a814a95ca597214c0a455">normalize_cond</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">normalize vector, return normalized vector and avoids div by zero <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Non-Euclidean norm calculations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp300029916dacdf81be9d7a094487737b"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1df4f42e49423bba9fb87d0f23ff41d"></a><!-- doxytag: member="VectorT::l1_norm" ref="af1df4f42e49423bba9fb87d0f23ff41d" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#af1df4f42e49423bba9fb87d0f23ff41d">l1_norm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute L1 (Manhattan) norm <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11415d423664b97a1b310632b77ca133"></a><!-- doxytag: member="VectorT::l8_norm" ref="a11415d423664b97a1b310632b77ca133" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a11415d423664b97a1b310632b77ca133">l8_norm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute l8_norm <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Minimum maximum and mean</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb744c92469202ca4ce1393dea3a2486f"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a518dc4009aefe63f5e78b3275e2b6680"></a><!-- doxytag: member="VectorT::max" ref="a518dc4009aefe63f5e78b3275e2b6680" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a518dc4009aefe63f5e78b3275e2b6680">max</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the maximal component <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac26e4238e21c149972f183420cbd6ac8"></a><!-- doxytag: member="VectorT::max_abs" ref="ac26e4238e21c149972f183420cbd6ac8" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ac26e4238e21c149972f183420cbd6ac8">max_abs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the maximal absolute component <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17547bec9dea921d7193030b52cd58ec"></a><!-- doxytag: member="VectorT::min" ref="a17547bec9dea921d7193030b52cd58ec" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a17547bec9dea921d7193030b52cd58ec">min</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the minimal component <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2ec0cc3933bb89ddbaa73da0d346555"></a><!-- doxytag: member="VectorT::min_abs" ref="ac2ec0cc3933bb89ddbaa73da0d346555" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ac2ec0cc3933bb89ddbaa73da0d346555">min_abs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the minimal absolute component <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06f6a6e6ecb327c85757a16035d832ad"></a><!-- doxytag: member="VectorT::mean" ref="a06f6a6e6ecb327c85757a16035d832ad" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a06f6a6e6ecb327c85757a16035d832ad">mean</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return arithmetic mean <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d2a5aefca80065de46bdb28bda7e7e6"></a><!-- doxytag: member="VectorT::mean_abs" ref="a8d2a5aefca80065de46bdb28bda7e7e6" args="() const " -->
Scalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a8d2a5aefca80065de46bdb28bda7e7e6">mean_abs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return absolute arithmetic mean <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62adf0fdb0ed34f65fdb1a88ababa934"></a><!-- doxytag: member="VectorT::minimize" ref="a62adf0fdb0ed34f65fdb1a88ababa934" args="(const vector_type &amp;_rhs)" -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a62adf0fdb0ed34f65fdb1a88ababa934">minimize</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">minimize values: same as *this = min(*this, _rhs), but faster <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e6e0439315dc8951e47f4c96e604662"></a><!-- doxytag: member="VectorT::minimized" ref="a4e6e0439315dc8951e47f4c96e604662" args="(const vector_type &amp;_rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a4e6e0439315dc8951e47f4c96e604662">minimized</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">minimize values and signalize coordinate minimization <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0325c83ed9ac61093908f06465245acf"></a><!-- doxytag: member="VectorT::maximize" ref="a0325c83ed9ac61093908f06465245acf" args="(const vector_type &amp;_rhs)" -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a0325c83ed9ac61093908f06465245acf">maximize</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximize values: same as *this = max(*this, _rhs), but faster <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0df8311e00ff433263c1a21dcd7e7106"></a><!-- doxytag: member="VectorT::maximized" ref="a0df8311e00ff433263c1a21dcd7e7106" args="(const vector_type &amp;_rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a0df8311e00ff433263c1a21dcd7e7106">maximized</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximize values and signalize coordinate maximization <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa1e87cd43f6fd915719e225a12b3fed"></a><!-- doxytag: member="VectorT::min" ref="aaa1e87cd43f6fd915719e225a12b3fed" args="(const vector_type &amp;_rhs)" -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#aaa1e87cd43f6fd915719e225a12b3fed">min</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise min <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab11b5bedc7af1446a7548602bc3e1fcb"></a><!-- doxytag: member="VectorT::max" ref="ab11b5bedc7af1446a7548602bc3e1fcb" args="(const vector_type &amp;_rhs)" -->
<a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#ab11b5bedc7af1446a7548602bc3e1fcb">max</a> (const <a class="el" href="classVectorT.html">vector_type</a> &amp;_rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">component-wise max <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18a2b371d7ebde925cf9a4cab943db3a"></a><!-- doxytag: member="VectorT::dim" ref="a18a2b371d7ebde925cf9a4cab943db3a" args="()" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a18a2b371d7ebde925cf9a4cab943db3a">dim</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns dimension of the vector (deprecated) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a378c56d8eb9e9f3258aca1ef389b87fa"></a><!-- doxytag: member="VectorT::size" ref="a378c56d8eb9e9f3258aca1ef389b87fa" args="()" -->
static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#a378c56d8eb9e9f3258aca1ef389b87fa">size</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns dimension of the vector <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab126c6306e691aaf0fecc88751624ad"></a><!-- doxytag: member="VectorT::vectorized" ref="aab126c6306e691aaf0fecc88751624ad" args="(const Scalar &amp;_s)" -->
static <a class="el" href="classVectorT.html">vector_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorT.html#aab126c6306e691aaf0fecc88751624ad">vectorized</a> (const Scalar &amp;_s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">store the same value in each component <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bbc370c00d61a00daf2ee2455301f16"></a><!-- doxytag: member="VectorT::size_" ref="a0bbc370c00d61a00daf2ee2455301f16" args="" -->
static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_</b> = N</td></tr>
</table>
<h3>template&lt;typename Scalar, int N&gt;<br/>
 class VectorT&lt; Scalar, N &gt;</h3>

<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a551a537492a30ae308689fc079a27218"></a><!-- doxytag: member="VectorT::operator%" ref="a551a537492a30ae308689fc079a27218" args="(const VectorT&lt; Scalar, 3 &gt; &amp;_rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorT.html">VectorT</a>&lt;Scalar,3&gt; <a class="el" href="classVectorT.html">VectorT</a>&lt; Scalar, N &gt;::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorT.html">VectorT</a>&lt; Scalar, 3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cross product: only defined for Vec3* as specialization </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceOpenMesh.html#af37af4054108f1fef53058ff57689763" title="Adapter for osg vector member computing a scalar product.">OpenMesh::cross</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0b99c174141169827de8da5326f40e46"></a><!-- doxytag: member="VectorT::operator/=" ref="a0b99c174141169827de8da5326f40e46" args="(const Scalar &amp;_s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorT.html">vector_type</a>&amp; <a class="el" href="classVectorT.html">VectorT</a>&lt; Scalar, N &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&nbsp;</td>
          <td class="paramname"> <em>_s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>component-wise self-division by scalar </p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>v *= (1/_s) is much faster than this </dd></dl>

</div>
</div>
<a class="anchor" id="a79eb5b7cfed6a4130e8226a2e15dede7"></a><!-- doxytag: member="VectorT::operator|" ref="a79eb5b7cfed6a4130e8226a2e15dede7" args="(const vector_type &amp;_rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classVectorT.html">VectorT</a>&lt; Scalar, N &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorT.html">vector_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compute scalar product </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceOpenMesh.html#a351b282a40719408090277956e526735" title="Adapter for osg vector member computing a scalar product.">OpenMesh::dot</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/data1/home1/moebius/projects/release/OpenMesh-2.0/src/OpenMesh/Core/Geometry/<a class="el" href="VectorT__inc_8hh_source.html">VectorT_inc.hh</a></li>
</ul>
</div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
