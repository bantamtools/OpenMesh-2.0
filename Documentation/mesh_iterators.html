<html>
    <head>
      <title>OpenMesh: Mesh Iterators and Circulators</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">OpenMesh Documentation</a>      </li>
      <li><a class="el" href="mesh_docu.html">Using and understanding OpenMesh</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Mesh Iterators and Circulators </h1>  </div>
</div>
<div class="contents">
<ul>
<li><a class="el" href="mesh_iterators.html#it_iters">Iterators</a></li>
<li><a class="el" href="mesh_iterators.html#it_iters_h">How to use iterators in OpenMesh</a></li>
<li><a class="el" href="mesh_iterators.html#it_circs">Circulators</a></li>
<li><a class="el" href="mesh_iterators.html#it_circs_h">How to use circulators in OpenMesh</a></li>
</ul>
<h2><a class="anchor" id="it_iters"></a>
Iterators</h2>
<p>The mesh provides linear iterators (that enumerate vertices, halfedges, edges, and faces). These can be used to easily navigate through a mesh. Each iterator <code>XYZIter</code> also exists in a const version <code>ConstXYZIter</code>.</p>
<p>All iterators are defined in the namespace <a class="el" href="namespaceOpenMesh_1_1Iterators.html" title="Contains all mesh iterators and circulators.">OpenMesh::Iterators</a>. They are template classes that expect a mesh as template argument to be fully specified. You should use the iterator types provided by the mesh itself, i.e. <code>MyMesh::VertexIter</code> instead of <code>OpenMesh::Iterators::VertexIterT&lt;MyMesh&gt;</code>.</p>
<p>The iterators are:</p>
<div class="fragment"><pre class="fragment">MyMesh mesh;

<span class="comment">// iterate over all vertices</span>
<span class="keywordflow">for</span> (MyMesh::VertexIter v_it=mesh.vertices_begin(); v_it!=mesh.vertices_end(); ++v_it) 
   ...; <span class="comment">// do something with *v_it, v_it-&gt;, or v_it.handle()</span>

<span class="comment">// iterate over all halfedges</span>
<span class="keywordflow">for</span> (MyMesh::HalfedgeIter h_it=mesh.halfedges_begin(); h_it!=mesh.halfedges_end(); ++h_it) 
   ...; <span class="comment">// do something with *h_it, h_it-&gt;, or h_it.handle()</span>

<span class="comment">// iterate over all edges</span>
<span class="keywordflow">for</span> (MyMesh::EdgeIter e_it=mesh.edges_begin(); e_it!=mesh.edges_end(); ++e_it) 
   ...; <span class="comment">// do something with *e_it, e_it-&gt;, or e_it.handle()</span>

<span class="comment">// iterator over all faces</span>
<span class="keywordflow">for</span> (MyMesh::FaceIter f_it=mesh.faces_begin(); f_it!=mesh.faces_end(); ++f_it) 
   ...; <span class="comment">// do something with *f_it, f_it-&gt;, or f_it.handle()</span>

</pre></div><p>The corresponding <code>const</code> counterparts are</p>
<ul>
<li><code>ConstVertexIter</code>, </li>
<li><code>ConstHalfedgeIter</code>, </li>
<li><code>ConstEdgeIter</code>, </li>
<li><code>ConstFaceIter</code>.</li>
</ul>
<p>The linear iterators are (almost) conformant to STL iterators. For a description of their interface see OpenMesh::Concepts::IteratorT.</p>
<p>For efficiency reasons the <code>operation++</code>(int) (post-increment) and <code>operation--</code>(int) (post-decrement) are not implemented. Hence, when using iterators, use the pre-increment operation (++it). Additionally to the standard operations, each linear iterator provides a method <code>handle()</code>, which returns the handle of the item referred to by the iterator.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>An iterator to an item usually needs more memory than a handle of an item. To store many references to an item, it is therefore better to use handles.</dd></dl>
<h2><a class="anchor" id="it_iters_h"></a>
How to use iterators in OpenMesh</h2>
<p>This example shows how to iterate over all faces of a mesh:</p>
<div class="fragment"><pre class="fragment">MyMesh mesh;

<span class="keywordflow">for</span>(MyMesh::FaceIter f_it = mesh.faces_begin(); f_it != mesh.faces_end(); ++f_it) {
    std::cout &lt;&lt; <span class="stringliteral">&quot;The face&#39;s valence is &quot;</span> &lt;&lt; mesh.valence( f_it.handle() ) &lt;&lt; std::endl;
}
</pre></div><h2><a class="anchor" id="it_circs"></a>
Circulators</h2>
<p>OpenMesh also provides so called Circulators that provide means to enumerate items adjacent to another item of the same or another type. For example, a <code>VertexVertexIter</code> allows to enumerate all vertices immediately adjacent to a (center) vertex (i.e. it allows to enumerate the so-called 1-ring of the center vertex). Analogously, a <code>FaceHalfedgeIter</code> enumerates all the halfedges belonging to a face. In general, <code>CenterItem_AuxiliaryInformation_TargetItem_Iter</code> designates a circulator that enumerates all the target items around a given center item.</p>
<p>The constructor of a circulator is of the form <code>Circulator(MeshType mesh, TargetHandle center_handle)</code>, i.e. it takes a mesh and the handle of the item to circulate around.</p>
<p>The circulators around a vertex are:</p>
<ul>
<li><code>VertexVertexIter:</code> iterate over all neighboring vertices. </li>
<li><code>VertexIHalfedgeIter:</code> iterate over all <em>incoming</em> halfedges. </li>
<li><code>VertexOHalfedgeIter:</code> iterate over all <em>outgoing</em> halfedges. </li>
<li><code>VertexEdgeIter:</code> iterate over all incident edges. </li>
<li><code>VertexFaceIter:</code> iterate over all adjacent faces.</li>
</ul>
<p>The circulators around a face are:</p>
<ul>
<li><code>FaceVertexIter:</code> iterate over the face's vertices. </li>
<li><code>FaceHalfedgeIter:</code> iterate over the face's halfedges. </li>
<li><code>FaceEdgeIter:</code> iterate over the face's edges. </li>
<li><code>FaceFaceIter:</code> iterate over all edge-neighboring faces.</li>
</ul>
<p>All circulators provide the operations listed in CirculatorT&lt;Mesh&gt;, which are basically the same as the iterator funtions.</p>
<p>Furthermore, circulators provide <code>operator</code> <code>bool()</code>, which returns true, as long as the circulator hasn't reached the end of the sequence.</p>
<p>OpenMesh provides the following functions (defined in <a class="el" href="classOpenMesh_1_1PolyConnectivity.html" title="Connectifity Class for polygonal meshes.">OpenMesh::PolyConnectivity</a>) to get circulators around a specified center item:</p>
<div class="fragment"><pre class="fragment"><span class="comment">/**************************************************</span>
<span class="comment"> * Vertex circulators</span>
<span class="comment"> **************************************************/</span>

<span class="comment">// Get the vertex-vertex circulator (1-ring) of vertex _vh</span>
VertexVertexIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#a68c1388ce7b5ce1cc9cf8825293ac801" title="vertex - vertex circulator">OpenMesh::PolyConnectivity::vv_iter</a> (VertexHandle _vh);

<span class="comment">// Get the vertex-incoming halfedges circulator of vertex _vh</span>
VertexIHalfedgeIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#ad107901645041fc7f0662ef92c3a079b" title="vertex - incoming halfedge circulator">OpenMesh::PolyConnectivity::vih_iter</a> (VertexHandle _vh);

<span class="comment">// Get the vertex-outgoing halfedges circulator of vertex _vh</span>
VertexOHalfedgeIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#ac93ceccd63aed16bcab88930c89ffbbb" title="vertex - outgoing halfedge circulator">OpenMesh::PolyConnectivity::voh_iter</a> (VertexHandle _vh);

<span class="comment">// Get the vertex-edge circulator of vertex _vh</span>
VertexEdgeIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#af695c0e03e74577d8d97347ca84b1ff2" title="vertex - edge circulator">OpenMesh::PolyConnectivity::ve_iter</a> (VertexHandle _vh);

<span class="comment">// Get the vertex-face circulator of vertex _vh</span>
VertexFaceIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#a25860bb9999a9b507b3a80e2e37a2e82" title="vertex - face circulator">OpenMesh::PolyConnectivity::vf_iter</a> (VertexHandle _vh);

<span class="comment">/**************************************************</span>
<span class="comment"> * Face circulators</span>
<span class="comment"> **************************************************/</span>

<span class="comment">// Get the face-vertex circulator of face _fh</span>
FaceVertexIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#ad063456d88df23b6987a7627ffbd1cdf" title="face - vertex circulator">OpenMesh::PolyConnectivity::fv_iter</a> (FaceHandle _fh);

<span class="comment">// Get the face-halfedge circulator of face _fh</span>
FaceHalfedgeIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#a2a0cf023e9159c558bd99f11758dd0d4" title="face - halfedge circulator">OpenMesh::PolyConnectivity::fh_iter</a> (FaceHandle _fh);

<span class="comment">// Get the face-edge circulator of face _fh</span>
FaceEdgeIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#abf21db5a31b161e47db2539f10ea200c" title="face - edge circulator">OpenMesh::PolyConnectivity::fe_iter</a> (FaceHandle _fh);

<span class="comment">// Get the face-face circulator of face _fh</span>
FaceFaceIter <a class="code" href="classOpenMesh_1_1PolyConnectivity.html#adb6d2e735b9fdc6750e0c7d47cd2b153" title="face - face circulator">OpenMesh::PolyConnectivity::ff_iter</a> (FaceHandle _fh);
</pre></div><p>Note that for every circulator there also exists a constant version. To make use of these constant circulators just add the prefix<br/>
 "Const" to the type specifier and add the prefix "c" to the function used to request the circulator of an item. Example:<br/>
</p>
<div class="fragment"><pre class="fragment">ConstVertexVertexIter cvvit = mesh.cvv_iter(some_vertex_handle);
</pre></div><h2><a class="anchor" id="it_circs_h"></a>
How to use circulators in OpenMesh</h2>
<p>The following code example now shows how to enumerate the 1-ring of each vertex:</p>
<div class="fragment"><pre class="fragment">MyMesh mesh;

<span class="comment">// (linearly) iterate over all vertices</span>
<span class="keywordflow">for</span> (MyMesh::VertexIter v_it=mesh.vertices_begin(); v_it!=mesh.vertices_end(); ++v_it)
{
  <span class="comment">// circulate around the current vertex</span>
  <span class="keywordflow">for</span> (<a class="code" href="classOpenMesh_1_1PolyMeshT.html#adc7d422e2ce13141e8291f7d29f7ecef" title="Circulator.">MyMesh::VertexVertexIter</a> vv_it=mesh.vv_iter(v_it.handle()); vv_it; ++vv_it)
  {
    <span class="comment">// do something with e.g. mesh.point(*vv_it)</span>
  }
}
</pre></div><p>Enumerating all halfedges adjacent to a certain face (the inner halfedges) is accomplished as follows:</p>
<div class="fragment"><pre class="fragment">MyMesh mesh;

...

<span class="comment">// Assuming faceHandle contains the face handle of the target face</span>

MyMesh::FaceHalfedgeIter fh_it = mesh.fh_iter(faceHandle);

<span class="keywordflow">for</span>(; fh_it; ++fh_it) {
    std::cout &lt;&lt; <span class="stringliteral">&quot;Halfedge has handle &quot;</span> &lt;&lt; fh_it.handle() &lt;&lt; std::endl;
}
</pre></div> </div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
