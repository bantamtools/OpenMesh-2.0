<html>
    <head>
      <title>OpenMesh: Using (custom) properties</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="main.html">OpenMesh Documentation</a>      </li>
      <li><a class="el" href="tutorial.html">Tutorials (code examples)</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Using (custom) properties </h1>  </div>
</div>
<div class="contents">
<p>This examples shows:</p>
<ul>
<li>How to add and remove custom properties,</li>
<li>How to get and set the value of a custom property</li>
</ul>
<p>In the last example we computed the barycenter of each vertex' neighborhood and stored it in an array. It would be more convenient and less error-prone if we could store this data in the mesh and let OpenMesh manage the data. It would be even more helpful if we could attach such properties dynamically to the mesh.</p>
<p>OpenMesh provides dynamic properties, which can be attached to each mesh entity (vertex, face, edge, halfedge, and the mesh itself). We distinguish between custom and standard properties. A custom property is any user-defined property and is accessed via the member function <code>property</code>(..) via a handle and an entity handle (e.g. VertexHandle). Whereas the standard properties are accessed via special member functions, e.g. the vertex position is accessed with <code>point</code>(..) and a vertex handle.</p>
<p>In this example we will store the <code>cog-value</code> (see previous example) in an additional vertex property instead of keeping it in a separate array. To do so we define first a so-called property handle with the desired type (<code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#aed10fb4dfb536b53a5e20c8f2442eadf" title="Coordinate type.">MyMesh::Point</a></code>) and register the handle at the mesh:</p>
 <div class="fragment"><pre class="fragment">  <span class="comment">// this vertex property stores the computed centers of gravity</span>
  <a class="code" href="structOpenMesh_1_1VPropHandleT.html" title="Handle representing a vertex property.">OpenMesh::VPropHandleT&lt;MyMesh::Point&gt;</a> cogs;
  mesh.add_property(cogs);
</pre></div></p>
<p><br/>
The <code>mesh</code> allocates enough memory to hold as many elements of type <code><a class="el" href="classOpenMesh_1_1PolyMeshT.html#aed10fb4dfb536b53a5e20c8f2442eadf" title="Coordinate type.">MyMesh::Point</a></code> as number of vertices exist, and of course the mesh synchronizes all insert and delete operations on the vertices with the vertex properties.</p>
<p>Once the wanted property is registered we can use the property to calculate the barycenter of the neighborhood of each vertex <code>v_it</code> </p>
 <div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (vv_it=mesh.vv_iter( v_it ); vv_it; ++vv_it)
      {
        mesh.property(cogs,v_it) += mesh.point( vv_it );
        ++valence;
      }
      mesh.property(cogs,v_it) /= valence;
</pre></div></p>
<p><br/>
and finally set the new position for each vertex <code>v_it</code> </p>
 <div class="fragment"><pre class="fragment">        mesh.set_point( v_it, mesh.property(cogs,v_it) );
</pre></div></p>
<p><br/>
Below is the complete source code:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="comment">// --------------------</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh&gt;</span>

<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html" title="Triangle mesh based on the ArrayKernel.">OpenMesh::TriMesh_ArrayKernelT&lt;&gt;</a>  MyMesh;


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh  mesh;


  <span class="comment">// check command line options</span>
  <span class="keywordflow">if</span> (argc != 4) 
  {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage:  &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; #iterations infile outfile\n&quot;</span>;
    <span class="keywordflow">return</span> 1;
  }



  <span class="comment">// read mesh from stdin</span>
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#ae4b7d0255a084aca13f5c7a553b86e72" title="Read a mesh from file _filename.">OpenMesh::IO::read_mesh</a>(mesh, argv[2]) )
  {
     std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: Cannot read mesh from &quot;</span> &lt;&lt; argv[2] &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 1;
  }



  <span class="comment">// this vertex property stores the computed centers of gravity</span>
  <a class="code" href="structOpenMesh_1_1VPropHandleT.html" title="Handle representing a vertex property.">OpenMesh::VPropHandleT&lt;MyMesh::Point&gt;</a> cogs;
  mesh.add_property(cogs);

  <span class="comment">// smoothing mesh argv[1] times</span>
  MyMesh::VertexIter          v_it, v_end(mesh.vertices_end());
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#adc7d422e2ce13141e8291f7d29f7ecef" title="Circulator.">MyMesh::VertexVertexIter</a>    vv_it;
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#aed10fb4dfb536b53a5e20c8f2442eadf" title="Coordinate type.">MyMesh::Point</a>               cog;
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#a15372f27edf521d8e9028e2abccae342" title="Scalar type.">MyMesh::Scalar</a>              valence;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                i, N(atoi(argv[1]));

  
  <span class="keywordflow">for</span> (i=0; i &lt; N; ++i)
  {
    <span class="keywordflow">for</span> (v_it=mesh.vertices_begin(); v_it!=v_end; ++v_it)
    {      
      mesh.property(cogs,v_it).vectorize(0.0f);
      valence = 0;
      
      <span class="keywordflow">for</span> (vv_it=mesh.vv_iter( v_it ); vv_it; ++vv_it)
      {
        mesh.property(cogs,v_it) += mesh.point( vv_it );
        ++valence;
      }
      mesh.property(cogs,v_it) /= valence;
    }
    
    <span class="keywordflow">for</span> (v_it=mesh.vertices_begin(); v_it!=v_end; ++v_it)
      <span class="keywordflow">if</span> ( !mesh.is_boundary( v_it ) )
        mesh.set_point( v_it, mesh.property(cogs,v_it) );
  }


  <span class="comment">// write mesh to stdout</span>
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#ab6b68cf71ede53756653b31bd0e292a5" title="Write a mesh to the file _filename.">OpenMesh::IO::write_mesh</a>(mesh, argv[3]) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: cannot write mesh to &quot;</span> &lt;&lt; argv[3] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 1;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
